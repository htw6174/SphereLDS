<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Sphere LDS Explorer</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}
			body {
				font-family: system-ui, sans-serif;
				background: #1a1a2e;
				color: #eee;
				overflow: hidden;
			}
			#container {
				width: 100vw;
				height: 100vh;
			}
			#controls {
				position: fixed;
				top: 20px;
				left: 20px;
				background: rgba(0, 0, 0, 0.8);
				padding: 20px;
				border-radius: 8px;
				min-width: 320px;
				max-height: calc(100vh - 40px);
				overflow-y: auto;
			}
			#controls h2 {
				margin-bottom: 15px;
				font-size: 16px;
			}
			.control-group {
				margin-bottom: 15px;
			}
			.control-group label {
				display: block;
				margin-bottom: 5px;
				font-size: 13px;
				color: #aaa;
			}
			.control-group input[type="range"] {
				width: 100%;
			}
			.control-group .value {
				font-family: monospace;
				font-size: 14px;
				color: #7df;
			}
			.control-group input[type="number"] {
				width: 100%;
				padding: 5px;
				background: #333;
				border: 1px solid #555;
				color: #fff;
				border-radius: 4px;
			}
			.control-group select {
				width: 100%;
				padding: 8px;
				background: #333;
				border: 1px solid #555;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
			}
			.method-info {
				font-size: 11px;
				color: #888;
				margin-top: 5px;
				line-height: 1.4;
			}
			.param-group {
				background: rgba(255, 255, 255, 0.05);
				padding: 10px;
				border-radius: 4px;
				margin-bottom: 15px;
			}
			.param-group h3 {
				font-size: 12px;
				color: #7df;
				margin-bottom: 10px;
				text-transform: uppercase;
				letter-spacing: 0.5px;
			}
			#info {
				position: fixed;
				bottom: 20px;
				left: 20px;
				font-size: 12px;
				color: #666;
			}
			.checkbox-row {
				display: flex;
				gap: 20px;
			}
			.checkbox-row label {
				display: flex;
				align-items: center;
				gap: 5px;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<div id="controls">
			<h2>Sphere LDS Explorer</h2>

			<div class="control-group">
				<label>Method</label>
				<select id="method">
					<option value="r2">R2 Sequence (Plastic Constant)</option>
					<option value="fibonacci">Fibonacci Sphere (Golden Spiral)</option>
					<option value="halton">Halton Sequence</option>
					<option value="kritzinger">Kritzinger Spherical</option>
					<option value="random">Random (for comparison)</option>
				</select>
				<div class="method-info" id="method-info"></div>
			</div>

			<div class="param-group" id="r2-params">
				<h3>R2 Parameters</h3>
				<div class="control-group">
					<label>α₁: <span class="value" id="a1-val"></span></label>
					<input type="range" id="a1" min="0" max="1" step="0.0001" value="0.7548776662466927" />
				</div>
				<div class="control-group">
					<label>α₂: <span class="value" id="a2-val"></span></label>
					<input type="range" id="a2" min="0" max="1" step="0.0001" value="0.5698402909980532" />
				</div>
				<div class="control-group">
					<label style="font-size: 11px; color: #666;">
						Defaults are 1/g and 1/g² where g ≈ 1.32472 is the plastic constant
					</label>
				</div>
			</div>

			<div class="param-group" id="halton-params" style="display: none;">
				<h3>Halton Parameters</h3>
				<div class="control-group">
					<label>Base 1 (longitude)</label>
					<input type="number" id="base1" min="2" max="100" value="2" />
				</div>
				<div class="control-group">
					<label>Base 2 (latitude)</label>
					<input type="number" id="base2" min="2" max="100" value="3" />
				</div>
			</div>

			<div class="control-group">
				<label>n (point count)</label>
				<input type="number" id="n" min="1" max="10000" value="500" />
			</div>

			<div class="control-group">
				<label>Point size</label>
				<input type="range" id="pointSize" min="1" max="20" step="0.5" value="4" />
			</div>

			<div class="control-group checkbox-row">
				<label>
					<input type="checkbox" id="showSphere" checked /> Sphere
				</label>
				<label>
					<input type="checkbox" id="showPath" /> Path
				</label>
				<label>
					<input type="checkbox" id="animate" /> Animate
				</label>
			</div>
		</div>

		<div id="info">Drag to rotate, scroll to zoom</div>

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";

			// Constants
			const PHI = (1 + Math.sqrt(5)) / 2; // Golden ratio
			const PLASTIC = 1.32471795724474602596; // Plastic constant (real root of x³ = x + 1)

			// Method descriptions
			const methodInfo = {
				r2: "Maps the R2 sequence to sphere via equal-area projection. Uses plastic constant for optimal 2D gap-filling. O(1) per point.",
				fibonacci:
					"Classic Fibonacci sphere / golden spiral. Very uniform but creates visible spiral structure. O(1) per point.",
				halton:
					"Halton sequence mapped to sphere. Different prime bases for each axis. O(log n) per point.",
				kritzinger:
					"Kritzinger's spherical sequence using golden ratio for longitude and sqrt for latitude. O(1) per point.",
				random: "Uniform random points for comparison. Not low-discrepancy.",
			};

			// Scene setup
			const container = document.getElementById("container");
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(
				60,
				window.innerWidth / window.innerHeight,
				0.1,
				100,
			);
			camera.position.set(0, 0, 3);

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(window.devicePixelRatio);
			container.appendChild(renderer.domElement);

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;

			// Reference sphere
			const sphereGeom = new THREE.SphereGeometry(0.98, 64, 32);
			const sphereMat = new THREE.MeshBasicMaterial({
				color: 0x223344,
				transparent: true,
				opacity: 0.3,
				wireframe: false,
			});
			const sphere = new THREE.Mesh(sphereGeom, sphereMat);
			scene.add(sphere);

			// Points
			let pointsObj = null;
			let lineObj = null;

			// ============================================
			// LDS Generation Methods
			// ============================================

			// Halton sequence for a given base
			function halton(index, base) {
				let result = 0;
				let f = 1 / base;
				let i = index;
				while (i > 0) {
					result += f * (i % base);
					i = Math.floor(i / base);
					f /= base;
				}
				return result;
			}

			// R2 sequence mapped to sphere
			// Uses equal-area cylindrical projection (Lambert)
			function generateR2(n, alpha1, alpha2) {
				const points = [];
				for (let i = 0; i < n; i++) {
					// R2 sequence in unit square
					const u = (0.5 + i * alpha1) % 1;
					const v = (0.5 + i * alpha2) % 1;

					// Map to sphere via equal-area projection
					// theta = longitude, phi = latitude
					const theta = 2 * Math.PI * u;
					const z = 1 - 2 * v; // z in [-1, 1]
					const r = Math.sqrt(1 - z * z);

					points.push(
						new THREE.Vector3(r * Math.cos(theta), z, r * Math.sin(theta)),
					);
				}
				return points;
			}

			// Fibonacci sphere (golden spiral)
			function generateFibonacci(n) {
				const points = [];
				const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.4 radians

				for (let i = 0; i < n; i++) {
					// Distribute points evenly along z-axis
					const z = 1 - (2 * i + 1) / n;
					const r = Math.sqrt(1 - z * z);

					// Golden angle increment for longitude
					const theta = goldenAngle * i;

					points.push(
						new THREE.Vector3(r * Math.cos(theta), z, r * Math.sin(theta)),
					);
				}
				return points;
			}

			// Halton sequence on sphere
			function generateHalton(n, base1, base2) {
				const points = [];
				for (let i = 1; i <= n; i++) {
					// Skip 0 for Halton
					const u = halton(i, base1);
					const v = halton(i, base2);

					const theta = 2 * Math.PI * u;
					const z = 1 - 2 * v;
					const r = Math.sqrt(1 - z * z);

					points.push(
						new THREE.Vector3(r * Math.cos(theta), z, r * Math.sin(theta)),
					);
				}
				return points;
			}

			// Kritzinger's spherical sequence
			// Uses golden ratio for longitude, different approach for latitude
			function generateKritzinger(n) {
				const points = [];
				const phiInv = 1 / PHI;

				for (let i = 0; i < n; i++) {
					// Longitude: golden ratio sequence
					const u = (i * phiInv) % 1;
					const theta = 2 * Math.PI * u;

					// Latitude: square root spacing for equal-area
					// This ensures points are distributed by area, not angle
					const v = (i + 0.5) / n;
					const z = 1 - 2 * v;
					const r = Math.sqrt(1 - z * z);

					points.push(
						new THREE.Vector3(r * Math.cos(theta), z, r * Math.sin(theta)),
					);
				}
				return points;
			}

			// Random (for comparison)
			function generateRandom(n) {
				const points = [];
				for (let i = 0; i < n; i++) {
					// Uniform on sphere via rejection or direct method
					const u = Math.random();
					const v = Math.random();

					const theta = 2 * Math.PI * u;
					const z = 1 - 2 * v;
					const r = Math.sqrt(1 - z * z);

					points.push(
						new THREE.Vector3(r * Math.cos(theta), z, r * Math.sin(theta)),
					);
				}
				return points;
			}

			// ============================================
			// Visualization
			// ============================================

			let animationOffset = 0;

			function updateVisualization() {
				const method = document.getElementById("method").value;
				const n = parseInt(document.getElementById("n").value);
				const pointSize = parseFloat(
					document.getElementById("pointSize").value,
				);
				const showSphere = document.getElementById("showSphere").checked;
				const showPath = document.getElementById("showPath").checked;

				// Update method info
				document.getElementById("method-info").textContent = methodInfo[method];

				// Show/hide parameter groups
				document.getElementById("r2-params").style.display =
					method === "r2" ? "block" : "none";
				document.getElementById("halton-params").style.display =
					method === "halton" ? "block" : "none";

				// Update parameter displays
				const a1 = parseFloat(document.getElementById("a1").value);
				const a2 = parseFloat(document.getElementById("a2").value);
				document.getElementById("a1-val").textContent = a1.toFixed(6);
				document.getElementById("a2-val").textContent = a2.toFixed(6);

				// Generate points based on method
				let points;
				switch (method) {
					case "r2":
						points = generateR2(n, a1, a2);
						break;
					case "fibonacci":
						points = generateFibonacci(n);
						break;
					case "halton":
						const base1 = parseInt(document.getElementById("base1").value);
						const base2 = parseInt(document.getElementById("base2").value);
						points = generateHalton(n, base1, base2);
						break;
					case "kritzinger":
						points = generateKritzinger(n);
						break;
					case "random":
						points = generateRandom(n);
						break;
				}

				// Remove old objects
				if (pointsObj) {
					scene.remove(pointsObj);
					pointsObj.geometry.dispose();
					pointsObj.material.dispose();
				}
				if (lineObj) {
					scene.remove(lineObj);
					lineObj.geometry.dispose();
					lineObj.material.dispose();
				}

				// Create points geometry
				const geometry = new THREE.BufferGeometry();
				const positions = new Float32Array(points.length * 3);
				const colors = new Float32Array(points.length * 3);

				for (let i = 0; i < points.length; i++) {
					positions[i * 3] = points[i].x;
					positions[i * 3 + 1] = points[i].y;
					positions[i * 3 + 2] = points[i].z;

					// Color gradient: early points are blue, late points are orange
					const t = ((i + animationOffset) % points.length) / points.length;
					colors[i * 3] = t;
					colors[i * 3 + 1] = 0.5 - Math.abs(t - 0.5);
					colors[i * 3 + 2] = 1 - t;
				}

				geometry.setAttribute(
					"position",
					new THREE.BufferAttribute(positions, 3),
				);
				geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

				const material = new THREE.PointsMaterial({
					size: pointSize * 0.01,
					vertexColors: true,
					sizeAttenuation: true,
				});

				pointsObj = new THREE.Points(geometry, material);
				scene.add(pointsObj);

				// Create path line if enabled
				if (showPath && points.length > 1) {
					const lineGeom = new THREE.BufferGeometry();
					lineGeom.setAttribute(
						"position",
						new THREE.BufferAttribute(positions, 3),
					);
					lineGeom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

					const lineMat = new THREE.LineBasicMaterial({
						vertexColors: true,
						transparent: true,
						opacity: 0.5,
					});

					lineObj = new THREE.Line(lineGeom, lineMat);
					scene.add(lineObj);
				}

				// Toggle sphere visibility
				sphere.visible = showSphere;
			}

			// Event listeners
			document
				.getElementById("method")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("a1")
				.addEventListener("input", updateVisualization);
			document
				.getElementById("a2")
				.addEventListener("input", updateVisualization);
			document
				.getElementById("base1")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("base2")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("n")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("pointSize")
				.addEventListener("input", updateVisualization);
			document
				.getElementById("showSphere")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("showPath")
				.addEventListener("change", updateVisualization);

			window.addEventListener("resize", () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});

			// Initial render
			updateVisualization();

			// Animation loop
			function animate() {
				requestAnimationFrame(animate);

				if (document.getElementById("animate").checked) {
					animationOffset += 2;
					updateVisualization();
				}

				controls.update();
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>
