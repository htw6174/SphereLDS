<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Sphere LDS Explorer</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}
			body {
				font-family: system-ui, sans-serif;
				background: #1a1a2e;
				color: #eee;
				overflow: hidden;
			}
			#container {
				width: 100vw;
				height: 100vh;
			}
			#controls {
				position: fixed;
				top: 20px;
				left: 20px;
				background: rgba(0, 0, 0, 0.7);
				padding: 20px;
				border-radius: 8px;
				min-width: 280px;
			}
			#controls h2 {
				margin-bottom: 15px;
				font-size: 16px;
			}
			.control-group {
				margin-bottom: 15px;
			}
			.control-group label {
				display: block;
				margin-bottom: 5px;
				font-size: 13px;
				color: #aaa;
			}
			.control-group input[type="range"] {
				width: 100%;
			}
			.control-group .value {
				font-family: monospace;
				font-size: 14px;
				color: #7df;
			}
			.control-group input[type="number"] {
				width: 100%;
				padding: 5px;
				background: #333;
				border: 1px solid #555;
				color: #fff;
				border-radius: 4px;
			}
			.preset-buttons {
				display: flex;
				gap: 8px;
				flex-wrap: wrap;
				margin-bottom: 15px;
			}
			.preset-buttons button {
				padding: 6px 12px;
				background: #335;
				border: none;
				color: #fff;
				border-radius: 4px;
				cursor: pointer;
				font-size: 12px;
			}
			.preset-buttons button:hover {
				background: #447;
			}
			#info {
				position: fixed;
				bottom: 20px;
				left: 20px;
				font-size: 12px;
				color: #666;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<div id="controls">
			<h2>Sphere LDS Explorer</h2>

			<div class="preset-buttons">
				<button onclick="setPreset('phi-phi')">φ, φ</button>
				<button onclick="setPreset('phi-phi2')">φ, φ²</button>
				<button onclick="setPreset('phi-sqrt2')">φ, √2</button>
				<button onclick="setPreset('plastic')">Plastic</button>
			</div>

			<div class="control-group">
				<label
					>p1 (step size in turns): <span class="value" id="p1-val"></span
				></label>
				<input
					type="range"
					id="p1"
					min="0"
					max="1"
					step="0.0001"
					value="0.618033988749895"
				/>
			</div>

			<div class="control-group">
				<label
					>p2 (rotation in turns): <span class="value" id="p2-val"></span
				></label>
				<input
					type="range"
					id="p2"
					min="0"
					max="1"
					step="0.0001"
					value="0.618033988749895"
				/>
			</div>

			<div class="control-group">
				<label>n (point count)</label>
				<input type="number" id="n" min="1" max="10000" value="500" />
			</div>

			<div class="control-group">
				<label>Point size</label>
				<input
					type="range"
					id="pointSize"
					min="1"
					max="20"
					step="0.5"
					value="4"
				/>
			</div>

			<div class="control-group">
				<label>
					<input type="checkbox" id="showSphere" checked /> Show sphere
				</label>
			</div>

			<div class="control-group">
				<label> <input type="checkbox" id="showPath" /> Show path </label>
			</div>
		</div>

		<div id="info">Drag to rotate, scroll to zoom</div>

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";

			// Constants
			const PHI = 1.618033988749894; // Golden ratio ≈ 1.618
			const PHI_FRAC = PHI - 1; // Fractional part ≈ 0.618
			const PHI_SQ_FRAC = (PHI * PHI) % 1; // φ² mod 1
			const SQRT2_FRAC = Math.sqrt(2) - 1; // √2 fractional
			const PLASTIC = 1.324717957244746; // Plastic constant
			const PLASTIC_FRAC = PLASTIC - 1;

			// Scene setup
			const container = document.getElementById("container");
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(
				60,
				window.innerWidth / window.innerHeight,
				0.1,
				100,
			);
			camera.position.set(0, 0, 3);

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(window.devicePixelRatio);
			container.appendChild(renderer.domElement);

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;

			// Reference sphere
			const sphereGeom = new THREE.SphereGeometry(0.98, 64, 32);
			const sphereMat = new THREE.MeshBasicMaterial({
				color: 0x223344,
				transparent: true,
				opacity: 0.3,
				wireframe: false,
			});
			const sphere = new THREE.Mesh(sphereGeom, sphereMat);
			scene.add(sphere);

			// Points
			let pointsObj = null;
			let lineObj = null;

			// Generate LDS points on sphere
			// Uses quaternion to represent full frame state (position + heading)
			// Frame convention: local X = right, local Y = forward, local Z = up (position on sphere)
			function generatePoints(p1, p2, n) {
				const points = [];

				// Frame quaternion - starts at identity (pos = +Z, facing = +Y, right = +X)
				// We'll remap at the end so visual "up" is +Y
				let frame = new THREE.Quaternion();

				// // TEST use multiple axies which each update
				// let a1 = new THREE.Vector3(1, 0, 0);
				// let a2 = new THREE.Vector3(0, 1, 0);
				// let a3 = new THREE.Vector3(0, 0, 1);

				// Pre-compute the step rotation (pitch forward by p1 turns around local X axis)
				const stepAngle = p1 * Math.PI * 2;
				const stepQuat = new THREE.Quaternion().setFromAxisAngle(
					new THREE.Vector3(1, 0, 0),
					stepAngle,
				);

				// // Pre-compute the turn rotation (yaw by p2 turns around local Z axis)
				// const turnAngle = p2 * Math.PI * 2;
				// const turnQuat = new THREE.Quaternion().setFromAxisAngle(
				//   pos,
				//   turnAngle
				// );

				// Local Z axis in world coords gives our position on sphere
				const localZ = new THREE.Vector3(0, 0, 1);

				for (let i = 0; i < n; i++) {
					// // TEST: alternate rotating axies around each other
					// 	points.push(a1.clone());

					// const stepAngle = p1 * Math.PI * 2;
					// const t1 = new THREE.Quaternion().setFromAxisAngle(a1, stepAngle);
					// 	a2.applyQuaternion(t1)
					// 	a3.applyQuaternion(t1)

					// 	const turnAngle = p2 * Math.PI * 2;
					//  const t2 = new THREE.Quaternion().setFromAxisAngle(a2, turnAngle);
					//  a1.applyQuaternion(t2)
					//  a3.applyQuaternion(t2)

					// 	const twistAngle = p2 * Math.PI * 2;
					//  const t3 = new THREE.Quaternion().setFromAxisAngle(a3, turnAngle);
					//  a1.applyQuaternion(t2)
					//  a2.applyQuaternion(t2)

					// Extract position (local +Z transformed to world)
					const pos = localZ.clone().applyQuaternion(frame);
					points.push(pos);

					// new turn axis per step
					const turnAngle = p2 * Math.PI * 2;
					const turnQuat = new THREE.Quaternion().setFromAxisAngle(
						pos,
						turnAngle,
					);

					// Combined per-step rotation: step forward, then turn
					const combinedQuat = new THREE.Quaternion().multiplyQuaternions(
						turnQuat,
						stepQuat,
					);

					// Apply combined rotation: frame = frame * combinedQuat
					frame.multiply(combinedQuat);
					frame.normalize(); // numerical stability
				}

				return points;
			}

			function updateVisualization() {
				const p1 = parseFloat(document.getElementById("p1").value);
				const p2 = parseFloat(document.getElementById("p2").value);
				const n = parseInt(document.getElementById("n").value);
				const pointSize = parseFloat(
					document.getElementById("pointSize").value,
				);
				const showSphere = document.getElementById("showSphere").checked;
				const showPath = document.getElementById("showPath").checked;

				// Update display values
				document.getElementById("p1-val").textContent = p1.toFixed(6);
				document.getElementById("p2-val").textContent = p2.toFixed(6);

				// Generate points
				const points = generatePoints(p1, p2, n);

				// Remove old objects
				if (pointsObj) scene.remove(pointsObj);
				if (lineObj) scene.remove(lineObj);

				// Create points geometry
				const geometry = new THREE.BufferGeometry();
				const positions = new Float32Array(points.length * 3);
				const colors = new Float32Array(points.length * 3);

				for (let i = 0; i < points.length; i++) {
					positions[i * 3] = points[i].x;
					positions[i * 3 + 1] = points[i].y;
					positions[i * 3 + 2] = points[i].z;

					// Color gradient: early points are blue, late points are orange
					const t = i / points.length;
					colors[i * 3] = t;
					colors[i * 3 + 1] = 0.5 - Math.abs(t - 0.5);
					colors[i * 3 + 2] = 1 - t;
				}

				geometry.setAttribute(
					"position",
					new THREE.BufferAttribute(positions, 3),
				);
				geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

				const material = new THREE.PointsMaterial({
					size: pointSize * 0.01,
					vertexColors: true,
					sizeAttenuation: true,
				});

				pointsObj = new THREE.Points(geometry, material);
				scene.add(pointsObj);

				// Create path line if enabled
				if (showPath && points.length > 1) {
					const lineGeom = new THREE.BufferGeometry();
					lineGeom.setAttribute(
						"position",
						new THREE.BufferAttribute(positions, 3),
					);
					lineGeom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

					const lineMat = new THREE.LineBasicMaterial({
						vertexColors: true,
						transparent: false,
						opacity: 0.4,
					});

					lineObj = new THREE.Line(lineGeom, lineMat);
					scene.add(lineObj);
				}

				// Toggle sphere visibility
				sphere.visible = showSphere;
			}

			// Presets
			window.setPreset = function (name) {
				const p1Input = document.getElementById("p1");
				const p2Input = document.getElementById("p2");

				switch (name) {
					case "phi-phi":
						p1Input.value = PHI_FRAC;
						p2Input.value = PHI_FRAC;
						break;
					case "phi-phi2":
						p1Input.value = PHI_FRAC;
						p2Input.value = PHI_SQ_FRAC;
						break;
					case "phi-sqrt2":
						p1Input.value = PHI_FRAC;
						p2Input.value = SQRT2_FRAC;
						break;
					case "plastic":
						p1Input.value = PLASTIC_FRAC;
						p2Input.value = PLASTIC_FRAC;
						break;
				}

				updateVisualization();
			};

			// Event listeners
			document
				.getElementById("p1")
				.addEventListener("input", updateVisualization);
			document
				.getElementById("p2")
				.addEventListener("input", updateVisualization);
			document
				.getElementById("n")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("pointSize")
				.addEventListener("input", updateVisualization);
			document
				.getElementById("showSphere")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("showPath")
				.addEventListener("change", updateVisualization);

			window.addEventListener("resize", () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});

			// Initial render
			updateVisualization();

			// Animation loop
			function animate() {
				requestAnimationFrame(animate);
				controls.update();
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>
