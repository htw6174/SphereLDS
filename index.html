<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Sphere LDS Explorer</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}
			body {
				font-family: system-ui, sans-serif;
				background: #1a1a2e;
				color: #eee;
				overflow: hidden;
			}
			#container {
				width: 100vw;
				height: 100vh;
			}
			#controls {
				position: fixed;
				top: 20px;
				left: 20px;
				background: rgba(0, 0, 0, 0.8);
				padding: 20px;
				border-radius: 8px;
				min-width: 320px;
				max-height: calc(100vh - 40px);
				overflow-y: auto;
			}
			#controls h2 {
				margin-bottom: 15px;
				font-size: 16px;
			}
			.control-group {
				margin-bottom: 15px;
			}
			.control-group label {
				display: block;
				margin-bottom: 5px;
				font-size: 13px;
				color: #aaa;
			}
			.control-group input[type="range"] {
				width: 100%;
			}
			.control-group .value {
				font-family: monospace;
				font-size: 14px;
				color: #7df;
			}
			.control-group input[type="number"] {
				width: 100%;
				padding: 5px;
				background: #333;
				border: 1px solid #555;
				color: #fff;
				border-radius: 4px;
			}
			.control-group select {
				width: 100%;
				padding: 8px;
				background: #333;
				border: 1px solid #555;
				color: #fff;
				border-radius: 4px;
				font-size: 14px;
			}
			.method-info {
				font-size: 11px;
				color: #888;
				margin-top: 5px;
				line-height: 1.4;
			}
			.param-group {
				background: rgba(255, 255, 255, 0.05);
				padding: 10px;
				border-radius: 4px;
				margin-bottom: 15px;
			}
			.param-group h3 {
				font-size: 12px;
				color: #7df;
				margin-bottom: 10px;
				text-transform: uppercase;
				letter-spacing: 0.5px;
			}
			#info {
				position: fixed;
				bottom: 20px;
				left: 20px;
				font-size: 12px;
				color: #666;
			}
			.checkbox-row {
				display: flex;
				gap: 20px;
			}
			.checkbox-row label {
				display: flex;
				align-items: center;
				gap: 5px;
			}
			.param-input {
				width: 100%;
				padding: 6px 8px;
				background: #222;
				border: 1px solid #444;
				color: #7df;
				border-radius: 4px;
				font-family: monospace;
				font-size: 13px;
			}
			.param-input:focus {
				outline: none;
				border-color: #7df;
			}
			.preset-btn {
				padding: 4px 8px;
				background: #335;
				border: none;
				color: #fff;
				border-radius: 4px;
				cursor: pointer;
				font-size: 11px;
			}
			.preset-btn:hover {
				background: #447;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<div id="controls">
			<h2>Sphere LDS Explorer</h2>

			<div class="control-group">
				<label>Method</label>
				<select id="method">
					<optgroup label="2D Projection Methods">
						<option value="r2">R2 Sequence (Plastic Constant)</option>
						<option value="fibonacci">Fibonacci Sphere (Golden Spiral)</option>
						<option value="halton">Halton Sequence</option>
						<option value="kritzinger">Kritzinger Spherical</option>
					</optgroup>
					<optgroup label="Quaternion Methods">
						<option value="hopf">Hopf Fibration (R3→S³→S²)</option>
						<option value="grassmann">Grassmannian (Axis-Angle LDS)</option>
						<option value="trirot">Tri-Rotation (XYZ Compose)</option>
						<option value="graygrid">Gray-Code Cube Walk</option>
					</optgroup>
					<option value="random">Random (for comparison)</option>
				</select>
				<div class="method-info" id="method-info"></div>
			</div>

			<div class="param-group" id="r2-params">
				<h3>R2 Parameters</h3>
				<div class="control-group">
					<label>α₁ (longitude increment)</label>
					<input type="text" id="a1" value="" class="param-input" />
				</div>
				<div class="control-group">
					<label>α₂ (latitude increment)</label>
					<input type="text" id="a2" value="" class="param-input" />
				</div>
				<div class="control-group">
					<label>Seed offset</label>
					<input type="text" id="r2-seed" value="0.5" class="param-input" />
				</div>
				<div class="control-group" style="display: flex; gap: 8px; flex-wrap: wrap;">
					<button class="preset-btn" onclick="setR2Preset('plastic')">Plastic (1/g, 1/g²)</button>
					<button class="preset-btn" onclick="setR2Preset('phi')">Golden (1/φ, 1/φ²)</button>
					<button class="preset-btn" onclick="setR2Preset('sqrt')">√2, √3</button>
				</div>
				<div class="control-group">
					<label style="font-size: 11px; color: #666;">
						g ≈ 1.32471795724... is the plastic constant (x³=x+1)
					</label>
				</div>
			</div>

			<div class="param-group" id="halton-params" style="display: none;">
				<h3>Halton Parameters</h3>
				<div class="control-group">
					<label>Base 1 (longitude)</label>
					<input type="number" id="base1" min="2" max="100" value="2" />
				</div>
				<div class="control-group">
					<label>Base 2 (latitude)</label>
					<input type="number" id="base2" min="2" max="100" value="3" />
				</div>
			</div>

			<div class="param-group" id="quat-params" style="display: none;">
				<h3>Quaternion Parameters</h3>
				<div class="control-group">
					<label>α₁</label>
					<input type="text" id="q1" value="" class="param-input" />
				</div>
				<div class="control-group">
					<label>α₂</label>
					<input type="text" id="q2" value="" class="param-input" />
				</div>
				<div class="control-group">
					<label>α₃</label>
					<input type="text" id="q3" value="" class="param-input" />
				</div>
				<div class="control-group" style="display: flex; gap: 8px; flex-wrap: wrap;">
					<button class="preset-btn" onclick="setQuatPreset('plastic')">Plastic (1/g^n)</button>
					<button class="preset-btn" onclick="setQuatPreset('primes')">Prime Roots</button>
					<button class="preset-btn" onclick="setQuatPreset('metallic')">Metallic Means</button>
				</div>
			</div>

			<div class="control-group">
				<label>n (point count)</label>
				<input type="number" id="n" min="1" max="10000" value="500" />
			</div>

			<div class="control-group">
				<label>Point size</label>
				<input type="range" id="pointSize" min="1" max="20" step="0.5" value="4" />
			</div>

			<div class="control-group checkbox-row">
				<label>
					<input type="checkbox" id="showSphere" checked /> Sphere
				</label>
				<label>
					<input type="checkbox" id="showPath" /> Path
				</label>
				<label>
					<input type="checkbox" id="animate" /> Animate
				</label>
			</div>
		</div>

		<div id="info">Drag to rotate, scroll to zoom</div>

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";

			// Constants - computed to full JS precision
			const PHI = (1 + Math.sqrt(5)) / 2; // Golden ratio ≈ 1.618033988749895

			// Plastic constant: real root of x³ = x + 1
			// Computed via Newton's method for maximum precision
			const PLASTIC = (() => {
				let x = 1.3;
				for (let i = 0; i < 100; i++) {
					x = x - (x * x * x - x - 1) / (3 * x * x - 1);
				}
				return x;
			})(); // ≈ 1.3247179572447460259609

			// R2 sequence defaults
			const R2_DEFAULTS = {
				plastic: { a1: 1 / PLASTIC, a2: 1 / (PLASTIC * PLASTIC) },
				phi: { a1: 1 / PHI, a2: 1 / (PHI * PHI) },
				sqrt: { a1: Math.sqrt(2) - 1, a2: Math.sqrt(3) - 1 }
			};

			// Quaternion method defaults (3 parameters for R3-style sequences)
			const QUAT_DEFAULTS = {
				plastic: {
					q1: 1 / PLASTIC,
					q2: 1 / (PLASTIC * PLASTIC),
					q3: 1 / (PLASTIC * PLASTIC * PLASTIC)
				},
				primes: {
					q1: Math.sqrt(2) - 1,
					q2: Math.sqrt(3) - 1,
					q3: Math.sqrt(5) - 2
				},
				metallic: {
					q1: 1 / PHI,  // golden
					q2: 1 / (1 + Math.sqrt(2)),  // silver
					q3: 1 / ((3 + Math.sqrt(13)) / 2)  // bronze
				}
			};

			// Method descriptions
			const methodInfo = {
				r2: "Maps the R2 sequence to sphere via equal-area projection. Uses plastic constant for optimal 2D gap-filling. O(1) per point.",
				fibonacci:
					"Classic Fibonacci sphere / golden spiral. Very uniform but creates visible spiral structure. O(1) per point.",
				halton:
					"Halton sequence mapped to sphere. Different prime bases for each axis. O(log n) per point.",
				kritzinger:
					"Kritzinger's spherical sequence using golden ratio for longitude and sqrt for latitude. O(1) per point.",
				hopf:
					"R3 sequence mapped to S³ (unit quaternions), then projected to S² via Hopf fibration. Treats sphere as quotient of rotation space. O(1) per point.",
				grassmann:
					"Separate LDS for rotation axis (on S²) and rotation angle. Avoids single-axis bias by distributing axes uniformly. O(1) per point.",
				trirot:
					"Compose three rotations around fixed X, Y, Z axes with R3 sequence angles. No preferred direction when angles are incommensurate. O(1) per point.",
				graygrid:
					"Walk through rotation space using Gray-code-like progression. Minimizes consecutive point distance while covering uniformly. O(1) per point.",
				random: "Uniform random points for comparison. Not low-discrepancy.",
			};

			// Scene setup
			const container = document.getElementById("container");
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(
				60,
				window.innerWidth / window.innerHeight,
				0.1,
				100,
			);
			camera.position.set(0, 0, 3);

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(window.devicePixelRatio);
			container.appendChild(renderer.domElement);

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;

			// Reference sphere
			const sphereGeom = new THREE.SphereGeometry(0.98, 64, 32);
			const sphereMat = new THREE.MeshBasicMaterial({
				color: 0x223344,
				transparent: false,
				opacity: 0.3,
				wireframe: false,
			});
			const sphere = new THREE.Mesh(sphereGeom, sphereMat);
			scene.add(sphere);

			// Points
			let pointsObj = null;
			let lineObj = null;

			// ============================================
			// LDS Generation Methods
			// ============================================

			// Halton sequence for a given base
			function halton(index, base) {
				let result = 0;
				let f = 1 / base;
				let i = index;
				while (i > 0) {
					result += f * (i % base);
					i = Math.floor(i / base);
					f /= base;
				}
				return result;
			}

			// R2 sequence mapped to sphere
			// Uses equal-area cylindrical projection (Lambert)
			function generateR2(n, alpha1, alpha2, seed = 0.5) {
				const points = [];
				for (let i = 0; i < n; i++) {
					// R2 sequence in unit square
					const u = (seed + i * alpha1) % 1;
					const v = (seed + i * alpha2) % 1;

					// Map to sphere via equal-area projection
					// theta = longitude, phi = latitude
					const theta = 2 * Math.PI * u;
					const z = 1 - 2 * v; // z in [-1, 1]
					const r = Math.sqrt(1 - z * z);

					points.push(
						new THREE.Vector3(r * Math.cos(theta), z, r * Math.sin(theta)),
					);
				}
				return points;
			}

			// Fibonacci sphere (golden spiral)
			function generateFibonacci(n) {
				const points = [];
				const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.4 radians

				for (let i = 0; i < n; i++) {
					// Distribute points evenly along z-axis
					const z = 1 - (2 * i + 1) / n;
					const r = Math.sqrt(1 - z * z);

					// Golden angle increment for longitude
					const theta = goldenAngle * i;

					points.push(
						new THREE.Vector3(r * Math.cos(theta), z, r * Math.sin(theta)),
					);
				}
				return points;
			}

			// Halton sequence on sphere
			function generateHalton(n, base1, base2) {
				const points = [];
				for (let i = 1; i <= n; i++) {
					// Skip 0 for Halton
					const u = halton(i, base1);
					const v = halton(i, base2);

					const theta = 2 * Math.PI * u;
					const z = 1 - 2 * v;
					const r = Math.sqrt(1 - z * z);

					points.push(
						new THREE.Vector3(r * Math.cos(theta), z, r * Math.sin(theta)),
					);
				}
				return points;
			}

			// Kritzinger's spherical sequence
			// Uses golden ratio for longitude, different approach for latitude
			function generateKritzinger(n) {
				const points = [];
				const phiInv = 1 / PHI;

				for (let i = 0; i < n; i++) {
					// Longitude: golden ratio sequence
					const u = (i * phiInv) % 1;
					const theta = 2 * Math.PI * u;

					// Latitude: square root spacing for equal-area
					// This ensures points are distributed by area, not angle
					const v = (i + 0.5) / n;
					const z = 1 - 2 * v;
					const r = Math.sqrt(1 - z * z);

					points.push(
						new THREE.Vector3(r * Math.cos(theta), z, r * Math.sin(theta)),
					);
				}
				return points;
			}

			// Random (for comparison)
			function generateRandom(n) {
				const points = [];
				for (let i = 0; i < n; i++) {
					// Uniform on sphere via rejection or direct method
					const u = Math.random();
					const v = Math.random();

					const theta = 2 * Math.PI * u;
					const z = 1 - 2 * v;
					const r = Math.sqrt(1 - z * z);

					points.push(
						new THREE.Vector3(r * Math.cos(theta), z, r * Math.sin(theta)),
					);
				}
				return points;
			}

			// ============================================
			// Quaternion-Native Methods
			// ============================================

			// Hopf Fibration: R3 → S³ → S²
			// Maps 3D LDS to quaternions, then projects to sphere via Hopf map
			function generateHopf(n, a1, a2, a3) {
				const points = [];
				const seed = 0.5;

				for (let i = 0; i < n; i++) {
					// R3 sequence in unit cube
					const u1 = (seed + i * a1) % 1;
					const u2 = (seed + i * a2) % 1;
					const u3 = (seed + i * a3) % 1;

					// Map to S³ using spherical coordinates in 4D
					// This gives uniform distribution on S³
					const theta1 = 2 * Math.PI * u1;
					const theta2 = 2 * Math.PI * u2;
					const phi = Math.acos(1 - 2 * u3);  // arccos for uniform on sphere

					// S³ point as quaternion (w, x, y, z)
					const w = Math.cos(phi / 2) * Math.cos(theta1);
					const x = Math.cos(phi / 2) * Math.sin(theta1);
					const y = Math.sin(phi / 2) * Math.cos(theta2);
					const z = Math.sin(phi / 2) * Math.sin(theta2);

					// Hopf fibration: S³ → S²
					// Maps quaternion to point on sphere
					const px = 2 * (x * z + w * y);
					const py = 2 * (y * z - w * x);
					const pz = w * w + z * z - x * x - y * y;

					points.push(new THREE.Vector3(px, py, pz));
				}
				return points;
			}

			// Grassmannian: Separate LDS for axis and angle
			// Distributes rotation axes uniformly on S², angles uniformly in [0, π]
			function generateGrassmann(n, a1, a2, a3) {
				const points = [];
				const seed = 0.5;
				const refPoint = new THREE.Vector3(0, 0, 1);

				for (let i = 0; i < n; i++) {
					// Use R3 sequence
					const u1 = (seed + i * a1) % 1;
					const u2 = (seed + i * a2) % 1;
					const u3 = (seed + i * a3) % 1;

					// First two values define axis direction (uniform on S²)
					const axisTheta = 2 * Math.PI * u1;
					const axisZ = 1 - 2 * u2;
					const axisR = Math.sqrt(1 - axisZ * axisZ);
					const axis = new THREE.Vector3(
						axisR * Math.cos(axisTheta),
						axisZ,
						axisR * Math.sin(axisTheta)
					);

					// Third value defines rotation angle [0, 2π]
					// Using full range since we want to reach all points
					const angle = 2 * Math.PI * u3;

					// Create rotation quaternion and apply to reference
					const quat = new THREE.Quaternion().setFromAxisAngle(axis, angle);
					const point = refPoint.clone().applyQuaternion(quat);

					points.push(point);
				}
				return points;
			}

			// Tri-Rotation: Compose X, Y, Z rotations with R3 angles
			// No single preferred axis when using incommensurate angles
			function generateTrirot(n, a1, a2, a3) {
				const points = [];
				const seed = 0.5;
				const refPoint = new THREE.Vector3(0, 0, 1);

				const axisX = new THREE.Vector3(1, 0, 0);
				const axisY = new THREE.Vector3(0, 1, 0);
				const axisZ = new THREE.Vector3(0, 0, 1);

				for (let i = 0; i < n; i++) {
					// R3 sequence for three rotation angles
					const u1 = (seed + i * a1) % 1;
					const u2 = (seed + i * a2) % 1;
					const u3 = (seed + i * a3) % 1;

					// Convert to angles - using 2π range for full coverage
					const angleX = 2 * Math.PI * u1;
					const angleY = 2 * Math.PI * u2;
					const angleZ = 2 * Math.PI * u3;

					// Compose rotations: Rz * Ry * Rx (extrinsic order)
					const qx = new THREE.Quaternion().setFromAxisAngle(axisX, angleX);
					const qy = new THREE.Quaternion().setFromAxisAngle(axisY, angleY);
					const qz = new THREE.Quaternion().setFromAxisAngle(axisZ, angleZ);

					const combined = new THREE.Quaternion()
						.multiplyQuaternions(qz, qy)
						.multiply(qx);

					const point = refPoint.clone().applyQuaternion(combined);
					points.push(point);
				}
				return points;
			}

			// Gray-Code Cube Walk: Traverse 3D rotation parameter space
			// Uses bit-reversal and Gray code for optimal space-filling
			function generateGrayGrid(n, a1, a2, a3) {
				const points = [];
				const refPoint = new THREE.Vector3(0, 0, 1);

				// Helper: van der Corput sequence (base 2)
				function vdc(i) {
					let result = 0;
					let f = 0.5;
					let n = i;
					while (n > 0) {
						result += f * (n & 1);
						n = n >> 1;
						f *= 0.5;
					}
					return result;
				}

				// Helper: interleave bits for space-filling curve
				function interleave(x, y, z) {
					// Simple additive approach with different bases
					return [(x * a1) % 1, (y * a2) % 1, (z * a3) % 1];
				}

				for (let i = 0; i < n; i++) {
					// Use van der Corput sequences with different bases
					const vx = vdc(i);
					const vy = vdc(i * 2 + 1);
					const vz = vdc(i * 3 + 2);

					// Combine with irrational offsets
					const [u1, u2, u3] = interleave(vx, vy, vz);

					// Map to Euler angles for rotation
					// Using ZYX convention with weighted ranges
					const alpha = 2 * Math.PI * u1;  // rotation around Z
					const beta = Math.acos(1 - 2 * u2);  // rotation toward equator
					const gamma = 2 * Math.PI * u3;  // rotation around new Z

					// Build rotation from ZYZ Euler angles (common for sphere)
					const q1 = new THREE.Quaternion().setFromAxisAngle(
						new THREE.Vector3(0, 0, 1), alpha
					);
					const q2 = new THREE.Quaternion().setFromAxisAngle(
						new THREE.Vector3(0, 1, 0), beta
					);
					const q3 = new THREE.Quaternion().setFromAxisAngle(
						new THREE.Vector3(0, 0, 1), gamma
					);

					const combined = new THREE.Quaternion()
						.multiplyQuaternions(q1, q2)
						.multiply(q3);

					const point = refPoint.clone().applyQuaternion(combined);
					points.push(point);
				}
				return points;
			}

			// ============================================
			// Visualization
			// ============================================

			let animationOffset = 0;

			function updateVisualization() {
				const method = document.getElementById("method").value;
				const n = parseInt(document.getElementById("n").value);
				const pointSize = parseFloat(
					document.getElementById("pointSize").value,
				);
				const showSphere = document.getElementById("showSphere").checked;
				const showPath = document.getElementById("showPath").checked;

				// Update method info
				document.getElementById("method-info").textContent = methodInfo[method];

				// Determine which parameter group to show
				const quatMethods = ['hopf', 'grassmann', 'trirot', 'graygrid'];
				const isQuatMethod = quatMethods.includes(method);

				document.getElementById("r2-params").style.display =
					method === "r2" ? "block" : "none";
				document.getElementById("halton-params").style.display =
					method === "halton" ? "block" : "none";
				document.getElementById("quat-params").style.display =
					isQuatMethod ? "block" : "none";

				// Generate points based on method
				let points;
				switch (method) {
					case "r2":
						const a1 = parseFloat(document.getElementById("a1").value) || R2_DEFAULTS.plastic.a1;
						const a2 = parseFloat(document.getElementById("a2").value) || R2_DEFAULTS.plastic.a2;
						const seed = parseFloat(document.getElementById("r2-seed").value) || 0.5;
						points = generateR2(n, a1, a2, seed);
						break;
					case "fibonacci":
						points = generateFibonacci(n);
						break;
					case "halton":
						const base1 = parseInt(document.getElementById("base1").value);
						const base2 = parseInt(document.getElementById("base2").value);
						points = generateHalton(n, base1, base2);
						break;
					case "kritzinger":
						points = generateKritzinger(n);
						break;
					case "hopf":
						const hq1 = parseFloat(document.getElementById("q1").value) || QUAT_DEFAULTS.plastic.q1;
						const hq2 = parseFloat(document.getElementById("q2").value) || QUAT_DEFAULTS.plastic.q2;
						const hq3 = parseFloat(document.getElementById("q3").value) || QUAT_DEFAULTS.plastic.q3;
						points = generateHopf(n, hq1, hq2, hq3);
						break;
					case "grassmann":
						const gq1 = parseFloat(document.getElementById("q1").value) || QUAT_DEFAULTS.plastic.q1;
						const gq2 = parseFloat(document.getElementById("q2").value) || QUAT_DEFAULTS.plastic.q2;
						const gq3 = parseFloat(document.getElementById("q3").value) || QUAT_DEFAULTS.plastic.q3;
						points = generateGrassmann(n, gq1, gq2, gq3);
						break;
					case "trirot":
						const tq1 = parseFloat(document.getElementById("q1").value) || QUAT_DEFAULTS.plastic.q1;
						const tq2 = parseFloat(document.getElementById("q2").value) || QUAT_DEFAULTS.plastic.q2;
						const tq3 = parseFloat(document.getElementById("q3").value) || QUAT_DEFAULTS.plastic.q3;
						points = generateTrirot(n, tq1, tq2, tq3);
						break;
					case "graygrid":
						const cq1 = parseFloat(document.getElementById("q1").value) || QUAT_DEFAULTS.plastic.q1;
						const cq2 = parseFloat(document.getElementById("q2").value) || QUAT_DEFAULTS.plastic.q2;
						const cq3 = parseFloat(document.getElementById("q3").value) || QUAT_DEFAULTS.plastic.q3;
						points = generateGrayGrid(n, cq1, cq2, cq3);
						break;
					case "random":
						points = generateRandom(n);
						break;
				}

				// Remove old objects
				if (pointsObj) {
					scene.remove(pointsObj);
					pointsObj.geometry.dispose();
					pointsObj.material.dispose();
				}
				if (lineObj) {
					scene.remove(lineObj);
					lineObj.geometry.dispose();
					lineObj.material.dispose();
				}

				// Create points geometry
				const geometry = new THREE.BufferGeometry();
				const positions = new Float32Array(points.length * 3);
				const colors = new Float32Array(points.length * 3);

				for (let i = 0; i < points.length; i++) {
					positions[i * 3] = points[i].x;
					positions[i * 3 + 1] = points[i].y;
					positions[i * 3 + 2] = points[i].z;

					// Color gradient: early points are blue, late points are orange
					const t = ((i + animationOffset) % points.length) / points.length;
					colors[i * 3] = t;
					colors[i * 3 + 1] = 0.5 - Math.abs(t - 0.5);
					colors[i * 3 + 2] = 1 - t;
				}

				geometry.setAttribute(
					"position",
					new THREE.BufferAttribute(positions, 3),
				);
				geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

				const material = new THREE.PointsMaterial({
					size: pointSize * 0.01,
					vertexColors: true,
					sizeAttenuation: true,
				});

				pointsObj = new THREE.Points(geometry, material);
				scene.add(pointsObj);

				// Create path line if enabled
				if (showPath && points.length > 1) {
					const lineGeom = new THREE.BufferGeometry();
					lineGeom.setAttribute(
						"position",
						new THREE.BufferAttribute(positions, 3),
					);
					lineGeom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

					const lineMat = new THREE.LineBasicMaterial({
						vertexColors: true,
						transparent: true,
						opacity: 0.5,
					});

					lineObj = new THREE.Line(lineGeom, lineMat);
					scene.add(lineObj);
				}

				// Toggle sphere visibility
				sphere.visible = showSphere;
			}

			// R2 preset function
			window.setR2Preset = function(preset) {
				const defaults = R2_DEFAULTS[preset];
				if (defaults) {
					document.getElementById("a1").value = defaults.a1;
					document.getElementById("a2").value = defaults.a2;
					updateVisualization();
				}
			};

			// Quaternion preset function
			window.setQuatPreset = function(preset) {
				const defaults = QUAT_DEFAULTS[preset];
				if (defaults) {
					document.getElementById("q1").value = defaults.q1;
					document.getElementById("q2").value = defaults.q2;
					document.getElementById("q3").value = defaults.q3;
					updateVisualization();
				}
			};

			// Initialize inputs with defaults
			function initializeParams() {
				// R2 defaults
				document.getElementById("a1").value = R2_DEFAULTS.plastic.a1;
				document.getElementById("a2").value = R2_DEFAULTS.plastic.a2;
				// Quaternion defaults
				document.getElementById("q1").value = QUAT_DEFAULTS.plastic.q1;
				document.getElementById("q2").value = QUAT_DEFAULTS.plastic.q2;
				document.getElementById("q3").value = QUAT_DEFAULTS.plastic.q3;
			}

			// Event listeners
			document
				.getElementById("method")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("a1")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("a2")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("r2-seed")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("base1")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("base2")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("q1")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("q2")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("q3")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("n")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("pointSize")
				.addEventListener("input", updateVisualization);
			document
				.getElementById("showSphere")
				.addEventListener("change", updateVisualization);
			document
				.getElementById("showPath")
				.addEventListener("change", updateVisualization);

			window.addEventListener("resize", () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});

			// Initialize and render
			initializeParams();
			updateVisualization();

			// Animation loop
			function animate() {
				requestAnimationFrame(animate);

				if (document.getElementById("animate").checked) {
					animationOffset += 2;
					updateVisualization();
				}

				controls.update();
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>
